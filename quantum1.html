<!DOCTYPE html>
<html lang="en">

<head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1.0" />
    <meta name="google-site-verification" content="VXixwtxrf--qUV1swfStEg9jOGPKgUm6C3Ub_vouqmc" />
    <title>MecBar | The Mec Evolution </title>
    <link rel="icon" href="foto/favicon.ico"/>
    <!-- CSS  -->
    <!-- <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css">
    -->
    <script src="js/jquery-3.js"></script>
    
    <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">
   
    <link href="https://fonts.googleapis.com/css?family=Raleway|Satisfy" rel="stylesheet">
    <link href="css/style.css" type="text/css" rel="stylesheet" media="screen,projection" />

    <link href="css/style2.css" type="text/css" rel="stylesheet" media="screen,projection" />
    <link href="css/navbar.css" type="text/css" rel="stylesheet" media="screen,projection" />
 
</head>

<header>
    <nav>
        <li class="nav-wrapper back-home" id="head">
            <a href="http://www.mecbar.com/" class="brand-logo mecbar">Mecbar</a>
            <a href="#" data-activates="mobile-demo" class="button-collapse"><i class="material-icons">menu</i></a>

            <ul class="right hide-on-med-and-down">
                <!--  <li> <a class="btn" onclick="Materialize.toast('Hello', 4000, 'Ciao' ,4000 )">Touch Me</a> </li>
              -->

              <li><a href="http://www.mecbar.com/#Ablog">Blog</a></li>
              <li><a href="http://www.mecbar.com/#Ablock">Blockchain</a></li>
              <li><a href="http://www.mecbar.com/#Amachine">Machine Learning</a></li>
              <li><a href="http://www.mecbar.com/#Alinux">Linux</a></li>
              <li><a href="http://www.mecbar.com/#Aus">Contatti</a></li>
                <li>
                    <a href=""> </a>
                </li>
                <li>
                    <a href=""> </a>
                </li>
            </ul>
             <!--
              <ul class="side-nav" id="mobile-demo">
                <li><a href="#Ablog">Blog</a></li>
                <li><a href="#Adev">Windows Server</a></li>
                <li><a href="#Alinux">Linux</a></li>
                <li><a href="#Aus">Contatti</a></li>
            </ul>
         -->
            </li>
    </nav>
</header>
<style>
body, html {
  height: 100%;
  width: 100%;
  margin: 0px;
  padding:0px;
}



.parallax {
  width: 100%;
  height: 200px;

  background-image:  url('foto/qubase.png');
  background-size: 200px;   
  background-repeat: no-repeat;
  background-position:  top 100px center;
  background-attachment: fixed;  /*no parallax */
}

.parallax2 {
  width: 100%;
  height: 300px;

  background-image:  url('foto/qubit1.png'),
    url('foto/qubit2.png'),
    url('foto/qubit3.png'),
    url('foto/qubit4.png');
  background-size: 300px;   
  background-repeat: no-repeat;
  background-position:  left 50px center, left 300px center, left 600px center, left 900px center;
  background-attachment: fixed;  /*no parallax */
}



.titoli {
    color:rgb(81, 7, 218);
    font: menu;
    font-size: 30px;
    font-family: Georgia, 'Times New Roman', Times, serif;
    margin:30px;
    text-align :center;
    text-shadow: -6px -6px 15px rgba(227, 85, 140, 1);
    width: 90%;
}
.testoq {
    color:rgb(19, 5, 146);
    font-size: 20px;
    font-family: Georgia, 'Times New Roman', Times, serif;
    margin:10px;    
}


.terminal4 {
	margin-inline-start: 20px;
	padding-bottom: 15px;
	padding-top: 15px;
	padding-left: 125px;
	padding-right: 35px;
	color: rgb(0, 0, 0);
	line-height: 40px;
    font-size: 25px;
    font-family: 'Times New Roman', Times, serif;
	background-color: white;
	border-radius: 25px;
    border-color: darkblue;
    height: auto;
    width: auto;
    display: inline-block;
    transition: 3.7s;
}

.terminal3 {
	margin-inline-start: 20px;
	padding-bottom: 15px;
	padding-top: 15px;
	padding-left: 95px;
	padding-right: 35px;
	color: rgb(0, 0, 0);
	line-height: 40px;
    font-size: 25px;
    font-family: 'Times New Roman', Times, serif;
	background-color: white;
	border-radius: 25px;
    border-color: darkblue;
    height: auto;
    display: inline-block;
    transition: 3.7s;
    width: auto;
}

.terminal2 {
	margin-inline-start: 20px;
	padding-bottom: 15px;
	padding-top: 15px;
	padding-left: 65px;
	padding-right: 35px;
	color: rgb(0, 0, 0);
	line-height: 40px;
    font-size: 25px;
    font-family: 'Times New Roman', Times, serif;
	background-color: white;
	border-radius: 25px;
    border-color: darkblue;
    height: auto;
    width: auto;
    display: inline-block;
    transition: 3.7s;
}

.terminal {
	margin-inline-start: 20px;
	padding-bottom: 15px;
	padding-top: 15px;
	padding-left: 35px;
	padding-right: 35px;
	color: rgb(0, 0, 0);
	line-height: 40px;
    font-size: 25px;
    font-family: 'Times New Roman', Times, serif;
	background-color: white;
	border-radius: 25px;
    border-color: darkblue;
    width: 90%;
    height: auto;
    display: inline-block;
    transition: 3.7s;
}
.terminal:hover, 
.terminal2:hover, 
.terminal3:hover ,
.terminal4:hover  {
	color: white;
	background-color: black;
	
}

.ter {
    margin-inline-start: 20px;
	margin: 20px !important;
	padding-bottom: 5px;
	padding-top: 5px;
	padding-left: 35px;
	padding-right: 35px;
	color: white;
	line-height: 40px;
    font-size: 25px;
	background-color: rgb(36, 39, 216);
	border-radius: 25px;
    border-color: darkorange;
}
.srboxp1 {
    height:50px;
    font-size: 25px;
    /* max-height: 3200px;  */
    width: auto;
    padding: 40px !important;

    margin-top: 50px;
    margin-bottom: 70px;
    margin-left: 2%;
    margin-right: 2%;
    border-radius: 5px;
    /* box-shadow: 1px 5px 15px 0px black; */
    color: rgb(246, 246, 251);
    background-color: rgb(17, 13, 13);
    position: relative;
    -webkit-box-shadow: 15px -10px 12px -4px rgba(89, 89, 89, 0.92);
    -moz-box-shadow: 15px -10px 12px -4px rgba(89, 89, 89, 0.92);
    box-shadow: 15px 10px 12px 4px rgba(88, 85, 85, 0.92);

}

.sx {
    margin-left: 30px;
    margin-top: 30px;
    margin-bottom: 30px;
}
.sxt {
    margin-left: 30px;
    margin-top: 30px;
    margin-bottom: 30px;
}

img {
    margin-left: 50px;

}
.ante {
    max-width: 100%;
}

@media only screen and (min-width:50px) and (max-width: 600px) {
            img  {
                width: 100%;
                max-width: 500px;
                height: auto;
                margin: 1%;
              }
            canvas {
                width: 100%;
            }    
            body {
                overflow-x: hidden;
            }

          .terminal {
                width: 75%;
                padding: 2%;
                font-size: 15px;
                line-height:20px;
            }   
            .terminal2 {
                width: 75%;
                padding: 4%;
                font-size: 15px;
                line-height:20px;
            }
            .terminal3 {
                width: 75%;
                padding: 6%;
                font-size: 15px;
                line-height:20px;
            }
            .terminal4 {
                width: 75%;
                padding: 6%;
                font-size: 15px;
                line-height:20px;
            }
            
            .parallax2 {
              width : 0%;
              height: 0%;
            }
            .titoli {
                font-size: 15px;
                letter-spacing: -0.097em;
            }
            .sxt{
                margin: 1%;
            }


        }

</style>

<!-- 
    <body class="parallax">
        x mettere immagine come sfondo 
-->

<!--
    <scripto>
    window.onload = function() {
        var canvas = document.getElementById("CanvasQU");
        var ctx = canvas.getContext("2d");
        var img = document.getElementById("Block");
       ctx.drawImage(img, 10, 10);
    

    };
</scripto>
-->
<script>
var img = new Image();

// User Variables - customize these to change the image being scrolled, its
// direction, and the speed.

img.src = 'foto/TENSORX.png';
var CanvasXSize = 1372;
var CanvasYSize = 350;
var speed = 50; // lower is faster
var scale = .8;
var y = -4.5; // vertical offset

// Main program

var dx = 10;
var imgW;
var imgH;
var x = 0;
var clearX;
var clearY;
var ctx;

img.onload = function() {
    imgW = img.width * scale;
    imgH = img.height * scale;
    
    if (imgW > CanvasXSize) {
        // image larger than canvas
        x = CanvasXSize - imgW;
    }
    if (imgW > CanvasXSize) {
        // image width larger than canvas
        clearX = imgW;
    } else {
        clearX = CanvasXSize;
    }
    if (imgH > CanvasYSize) {
        // image height larger than canvas
        clearY = imgH;
    } else {
        clearY = CanvasYSize;
    }
    
    // get canvas context
    ctx = document.getElementById('CanvasQU').getContext('2d');
 
    // set refresh rate
    return setInterval(draw, speed);
}

function draw() {
    ctx.clearRect(0, 0, clearX, clearY); // clear the canvas
    
    // if image is <= Canvas Size
    if (imgW <= CanvasXSize) {
        // reset, start from beginning
        if (x > CanvasXSize) {
            x = -imgW + x;
        }
        // draw additional image1
        if (x > 0) {
            ctx.drawImage(img, -imgW + x, y, imgW, imgH);
        }
        // draw additional image2
        if (x - imgW > 0) {
            ctx.drawImage(img, -imgW * 2 + x, y, imgW, imgH);
        }
    }

    // image is > Canvas Size
    else {
        // reset, start from beginning
        if (x > (CanvasXSize)) {
            x = CanvasXSize - imgW;
        }
        // draw aditional image
        if (x > (CanvasXSize-imgW)) {
            ctx.drawImage(img, x - imgW + 1, y, imgW, imgH);
        }
    }
    // draw image
    ctx.drawImage(img, x, y,imgW, imgH);
    // amount to move
    x += dx;
}



</script>
<style>
   divo {
        overflow: hidden;
    }
    .ante {
        display: grid;
  justify-content: space-around;
  grid-template-columns:  auto;
    }
</style>
<body>
     
    <div id="uno" class="parallaxo"></div>    
    <div class="titoli">
        Programming in Quantum with Qiskit
    </div>
  <div class="ante">
    <canvas id="CanvasQU" width="1270" height="350">  
    </canvas>
  </div>
    <div class="terminal">
    

    Qiskit is a Python framework che permette di simulare la quantum computation, si compone di quattro elementi.
    Il primo Terra è la base  le fondamenta del quantum computing e permette la compilazione dei circuiti e l 'interazione con i backend.
    Poi abbiamo Aqua per la chimica, ottimizzazioni e per l'intelligenza artificiale mentre Aer è un simulatore ad alta performance.
    Infine Ignis per la gestione delle interferenze e degli errori.
    Con il quantum computing si ottengono dei risultati molto più veloci nella soluzione degli algoritmi matematici rispetto al tradizionale 
    computing.
    Ad esempio ad oggi ci sono degli algoritmi che con il quantum computing vengono risolti molto velocemente ad esempio il Deutsch-Jozsa algorithm,
    Simon algorithm ed il Bernstein-Vazirani algorithm. Quest'ultimo verrà poi analizzato in modo dettagliato.
  

     In questo post si parla della programmazione in Python del QUANTUM partendo dalla simulazione 
     di un quantum in Colab Notebooks, naturalmente è possibile installare le sottostanti librerie in un proprio
     ambiente virtuale ad esempio tramite Anaconda/Conda o tramite lo stesso Python. IBM permette di effettuare prove sul suo IBM Q 
     quantum computers.
    </div>
    <div class="parallax2"> </div>
  


    <div class="titoli">
        Esempi di creazione di un circuito quantico e sua visualizzazione 
        </div>    
    <div class="sxt">
            <em class="terminal">!pip install qiskit </em><br><br>
    </div>
    <div class="sxt">
        <em class="terminal">from qiskit import *</em><br><br>
        <em class="terminal">%config InlineBackend.figure_format = 'svg' # Config for images look nice</em><br><br>
        <em class="terminal">qc = QuantumCircuit()  #creo il circuito quantico</em><br><br>
        <em class="terminal">qr = QuantumRegister(2,'qreg')   #creo il registro quantico con 2 qubit</em><br><br>
        <em class="terminal">qc.add_register( qr )    #add il registro creato al cicuito definito vuoto</em><br><br>
        <em class="terminal">qc.qregs</em><br><br>
        <em class="terminal">qc.draw(output='mpl') #disegno il circuito - immagine sottostante</em><br><br>
    </div>
    <div>
        <img src="foto/q1.png" width="350px" height="200px">
    </div>

    
    <div class="sxt">
        <em class="terminal">qc.h( qr[0] )  #corretto  abbiamo 2 qubit  0 ed 1</em><br><br>
        <em class="terminal">qc.cx( qr[0], qr[1] );</em><br><br>
        <em class="terminal">qc.draw(output='mpl')</em><br><br>
    </div>
    <div>
        <img src="foto/q2.png" width="300px" height="200px">
    </div>
    <div class="sxt">
        <em class="terminal"> vector_sim = Aer.get_backend('statevector_simulator')  </em><br>   <br>               
            <em class="terminal">    job = execute( qc, vector_sim )</em><br><br>  
                <em class="terminal">     il resultato dell'esecuzione è job con cui ottengo lo stato del vector</em><br><br>  
                    <em class="terminal">     stato = job.result().get_statevector()</em><br><br>  
                        <em class="terminal"> for i,sta in enumerate(stato):</em><br><br>  
                            <em class="terminal">  print(i, sta)</em><br><br>
    </div>
    <div>
        <img src="foto/q3.png" width="300px" height="200px"><br>
        Il j in python equivale al simbolo dei numeri complessi.<br>
        This is the vector for a Bell state (∣∣00⟩+∣∣11⟩)/2‾√, which is what we'd expect given the circuit.<br>
        Ora altro esempio inizializzo circuito con altri parametri<br>
    </div>
    <div class="sxt">
        metodo measure con input qubit e differenti bit dove mettere output. Per misurare si usa ClassicalRegister<br>
        <em class="terminal">new_qc = QuantumCircuit( qr )</em><br><br>
        <em class="terminal"> new_qc.initialize( ket, qr )</em><br><br>
        <em class="terminal">cr = ClassicalRegister(2,'creg')</em><br><br>
        <em class="terminal">        qc.add_register(cr)</em><br><br>
        <em class="terminal">      qc.measure(qr[0],cr[0])</em><br><br>
        <em class="terminal"> qc.measure(qr[1],cr[1])</em><br><br>
        <em class="terminal"> qc.draw(output='mpl')</em><br><br>
    </div>
    <div>
       <img src="foto/q4.png" width="550px" height="300px">
    </div>
    <div class="sxt">
    Ora simuliamo un reale quantum device. Shots = numero di esecuzioni del circuito se non si inserisce un valore prende di default 1024<br>
    <em class="terminal">emulator = Aer.get_backend('qasm_simulator')</em><br><br>
        <em class="terminal">job = execute( qc, emulator, shots=1024 )</em><br><br>
        <em class="terminal"> ris = job.result().get_counts()</em><br><br>
        <em class="terminal">print(ris)</em><br><br>
    
          Risultato  :     {'11': 514, '00': 510}<br>
          Risultato in Istogramma<br>
          <br>
    

        <em class="terminal">  from qiskit.visualization import plot_histogram</em><br><br>

        <em class="terminal">plot_histogram( ris )</em><br><br>

    </div>
    <div>
        <img src="foto/q5.png" width="550px" height="350px">
     </div>
     <div class="sxt">
     Lista dei risultati<br>
     <em class="terminal"> job = execute( qc, emulator, shots=15, memory=True )</em><br><br>
        <em class="terminal"> lista = job.result().get_memory()</em><br><br>
            <em class="terminal">print(lista)</em><br><br>
     ['11', '11', '11', '11', '11', '11', '11', '11', '00', '11', '11', '00', '00', '11', '11']<br>

  
I risultati dellla lista vanno da dx a sx.<br>
 Sotto altro esempio con 8 qubit in cui si vede che 1 è a sx come per sistema binario 2 elevato alla 7 uguale a 10000000<br>
  
   <em class="terminal">qubit = QuantumRegister(10)</em><br><br>
   <em class="terminal">bit = ClassicalRegister(10)</em><br><br>
   <em class="terminal">circuit = QuantumCircuit(qubit,bit)</em><br><br>
    <em class="terminal">circuit.x(qubit[9])</em><br><br>
   <em class="terminal">circuit.measure(qubit,bit) # this is a way to do all the qc.measure(qr8[j],cr8[j]) at once</em><br><br>
    <em class="terminal">execute( circuit, emulator, shots=2000 ).result().get_counts()</em><br><br>
     
            {'1000000000': 2000}<br>

Input 3 = number of Qubit senza classical circuit<br>


<em class="terminal">qc = QuantumCircuit(3)</em><br><br>
    <em class="terminal">qc.h(1)   #add a gate in questo caso 0, 1 o 2 </em><br><br>
     
        <em class="terminal">qc.draw(output='mpl')</em><br><br>

        <div>
            <img src="foto/q6.png" width="450px" height="250px">
         </div>
<em class="terminal">qc.h(2)   #add a gate in questo caso 0, 1 o 2 </em><br><br>
<em class="terminal">qc.draw(output='mpl')</em><br><br>

<div>
    <img src="foto/q7.png" width="550px" height="250px">
 </div>
<div class="terminal">
Per definire un circuito con quantun e classical register si può inserire 2 parmetri, il primo è il numero qubits ed il secondo il numero dei bits. Nell' esempio sottostante inseriamo 3 qubits e 2 bit di output<br>
</div>
<em class="terminal">qc = QuantumCircuit(3,2)</em><br><br>
<em class="terminal">qc.h(2)</em><br><br>
 <em class="terminal">qc.cx(0,1)</em><br><br>
  <em class="terminal">qc.measure(1,0)</em><br><br>
    <em class="terminal">qc.draw(output='mpl')</em><br><br>
</div>

<div>
    <img src="foto/q8.png" width="550px" height="250px">
 </div>
<div class="sxt">
<b>Ora vediamo una rappresentazione grafica dei Qubit</b><br><br>

 <b> Matrices and the Bloch Sphere</b><br><br>
<em class="terminal">from qiskit import *</em><br><br>
<em class="terminal">from qiskit.visualization import plot_bloch_vector</em><br><br>
<em class="terminal">%config InlineBackend.figure_format = 'svg' </em><br><br>


<em class="terminal">qc = QuantumCircuit(1)</em><br><br>
<em class="terminal"># z measurement of qubit 0</em><br><br>
<em class="terminal">z = QuantumCircuit(1,1)</em><br><br>
<em class="terminal">z.measure(0,0);</em><br><br>

<em class="terminal"># x measurement of qubit 0</em><br><br>
<em class="terminal">x = QuantumCircuit(1,1)</em><br><br>
<em class="terminal">x.h(0)</em><br><br>
<em class="terminal">x.measure(0,0)</em><br><br>

<em class="terminal"># y measurement of qubit 0</em><br><br>
<em class="terminal">y = QuantumCircuit(1,1)</em><br><br>
<em class="terminal">y.sdg(0)</em><br><br>
<em class="terminal">y.h(0)</em><br><br>
<em class="terminal">y.measure(0,0);</em><br><br>


<em class="terminal">shots = 2**14 # number of samples used for statistics</em><br><br>

<em class="terminal">bloch_vector = []</em><br><br>

<em class="terminal">for circuito in [x, y, z]:</em><br><br>
    
<em class="terminal2">    # eseguo circuito misurando stato </em><br><br>
    <em class="terminal2">    counts = execute(qc+circuito,Aer.get_backend('qasm_simulator'),shots=shots).result().get_counts()</em><br><br>

    <em class="terminal2"> # calculo la probabilità per ogni bit </em><br><br>
    <em class="terminal2"> probs = {}</em><br><br>
    <em class="terminal2"> for output in ['0','1']:</em><br><br>
    <em class="terminal3">    if output in counts:</em><br><br>
    <em class="terminal4">        probs[output] = counts[output]/shots</em><br><br>
    <em class="terminal3">    else:</em><br><br>
    <em class="terminal4">       probs[output] = 0</em><br><br>
            
    <em class="terminal2">bloch_vector.append( probs['0'] -  probs['1'] )</em><br><br>


    <em class="terminal">plot_bloch_vector( bloch_vector )</em><br><br>
</div>

<div>
    <img src="foto/q10.png" width="550px" height="250px">
 </div>

 <div class="sxt">
       Creare custom gates<br>

Si possono creare circuiti più complessi anche creando custom gates.<br>
 Sotto un circuito cx tra qubits 0 e 2 con qubit 1 che esercita una mediazione tra gli altri 2.<br>

<em class="terminal">sc = QuantumCircuit(3, name='custom_cx')</em><br><br>
    <em class="terminal">sc.cx(0,1)</em><br><br>
        <em class="terminal">sc.cx(1,2)</em><br><br>
            <em class="terminal">sc.cx(0,1)</em><br><br>
                <em class="terminal">sc.cx(1,2)</em><br><br>
                    <em class="terminal">sc.cx(0,1)</em><br><br>
                        <em class="terminal">sc.cx(1,2)</em><br><br>
                            <em class="terminal">sc.draw(output='mpl')</em><br><br>


                        </div>

                        <div>
                            <img src="foto/q11.png" width="550px" height="250px">
                         </div>
  <div class="sxt">
    <em class="terminal">custom_cx = sc.to_instruction()</em><br><br>

      <em class="terminal">qr = QuantumRegister(4)</em><br><br>
     <em class="terminal">nqc = QuantumCircuit(qr)</em><br><br>

    <em class="terminal">nqc.append(custom_cx, [qr[1],qr[2],qr[3]])</em><br><br>
    <em class="terminal">nqc.draw(output='mpl')</em><br><br>
   </div>

    <div>
      <img src="foto/q12.png" width="550px" height="250px">
   </div>

   <div class="sxt">
    <em class="terminal">from qiskit import QuantumCircuit, execute, Aer</em><br><br>
        <em class="terminal">from qiskit.visualization import plot_histogram</em><br><br>
            <em class="terminal">%config InlineBackend.figure_format = 'svg' </em><br><br>
                <em class="terminal">n = 8</em><br><br>
                    <em class="terminal">qc1 = QuantumCircuit(n)</em><br><br>
                        <em class="terminal">qc1.x(7)</em><br><br>

                            <em class="terminal">qc1.draw(output='mpl')</em><br><br>

                                <em class="terminal">n1 = 8</em><br><br>
                                    <em class="terminal">n2 = 8</em><br><br>
                                        <em class="terminal">qc2 = QuantumCircuit(n1,n2)</em><br><br>

<em class="terminal">counts = execute(qc2,Aer.get_backend('qasm_simulator')).result().get_counts()</em><br><br>
    <em class="terminal">plot_histogram(counts)</em><br><br>

</div>
<div class="testoq">
    Risultato 0000000 <br>
    </div>
<div>
  <img src="foto/q13.png" width="550px" height="250px">
</div>
<div class="sxt">
Sommando i 2 circuiti il risultato è 10000000 perchè inserito X il NOT che inverte l'output <br>

<em class="terminal">for j in range(n):</em><br><br>
    <em class="terminal2">   qc2.measure(j,j)</em><br><br>

        <em class="terminal">qc = qc1 + qc2</em><br><br>

            <em class="terminal">qc.draw(output='mpl',justify='none')</em><br><br>

        </div>

        <div>
          <img src="foto/q14.png" width="550px" height="250px">
       </div>
<div class="sxt">
<em class="terminal">counts = execute(qc,Aer.get_backend('qasm_simulator')).result().get_counts()</em><br><br>
    <em class="terminal">plot_histogram(counts)</em><br><br>

</div>

<div>
  <img src="foto/q15.png" width="550px" height="250px">
</div>
<div class="sxt">
   <em class="terminal">#try CNOT</em><br><br>
    <em class="terminal">qc = QuantumCircuit(2,2)</em><br><br>
        <em class="terminal">qc.x(0)</em><br><br>
            <em class="terminal">qc.cx(0,1)</em><br><br>
                <em class="terminal">qc.measure(0,0)</em><br><br>
                    <em class="terminal">qc.measure(1,1)</em><br><br>
                        <em class="terminal">qc.draw(output='mpl')</em><br><br>

</div>

                    <div>
                      <img src="foto/q16.png" width="550px" height="250px">
                   </div>


<div class="sxt">
<em class="terminal">qc = QuantumCircuit(2,2)</em><br><br>
    <em class="terminal">qc.cx(0,1)</em><br><br>
        <em class="terminal">qc.measure(0,0)</em><br><br>
            <em class="terminal">qc.measure(1,1)</em><br><br>
                <em class="terminal">qc.draw(output='mpl')</em><br><br>

 </div>

            <div>
              <img src="foto/q17.png" width="550px" height="250px">
           </div>

<div class="sxt">
<em class="terminal">counts = execute(qc,Aer.get_backend('qasm_simulator')).result().get_counts()</em><br><br>
    <em class="terminal">plot_histogram(counts)</em><br><br>


</div>

<div>
  <img src="foto/q18.png" width="550px" height="250px">
</div>
<div class="sxt">
<em class="terminal">#test cnor </em><br><br>
    <em class="terminal"># 0 e 0 -- 1 e 1 = 1</em><br><br>
        <em class="terminal"># 0 e 1 -- 1 e 0 = 1</em><br><br>

            <em class="terminal">qc_ha = QuantumCircuit(4,2)</em><br><br>
                <em class="terminal"># encode inputs in qubits 0 and 1</em><br><br>
                    <em class="terminal">qc_ha.x(0) # For a=0, remove this line. For a=1, leave it.</em><br><br>
                        <em class="terminal">qc_ha.x(1) # For b=0, remove this line. For b=1, leave it.</em><br><br>
                            <em class="terminal">qc_ha.barrier()</em><br><br>
                                <em class="terminal"># use cnots to write the XOR of the inputs on qubit 2</em><br><br>
                                    <em class="terminal">qc_ha.cx(0,2)</em><br><br>
                                        <em class="terminal">c_ha.cx(1,2)</em><br><br>
                                            <em class="terminal">qc_ha.barrier()</em><br><br>
                                                <em class="terminal"># extract outputs</em><br><br>
                                                    <em class="terminal">qc_ha.measure(2,0) # extract XOR value</em><br><br>
                                                        <em class="terminal">qc_ha.measure(3,1)</em><br><br>

                                                            <em class="terminal">qc_ha.draw(output='mpl')</em><br><br>

</div>

  <div>
    <img src="foto/q19.png" width="550px" height="250px">
  </div>
<div class="terminal">

For this we need a new gate: like a CNOT, but controlled on two qubits instead of just one. This will perform a NOT on the target qubit only when both controls are in state 1.
 This new gate is called the Toffoli. For those of you who are familiar with Boolean logic gates, it is basically an AND gate.<br>

<em class="terminal">qc_ha = QuantumCircuit(4,2)</em><br><br>
    <em class="terminal"># encode inputs in qubits 0 and 1</em><br><br>
        <em class="terminal">qc_ha.x(0) # For a=0, remove the this line. For a=1, leave it.</em><br><br>
            <em class="terminal">qc_ha.x(1) # For b=0, remove the this line. For b=1, leave it.</em><br><br>
                <em class="terminal">qc_ha.barrier()</em><br><br>
                    <em class="terminal"># use cnots to write the XOR of the inputs on qubit 2</em><br><br>
                        <em class="terminal">qc_ha.cx(0,2)</em><br><br>
                            <em class="terminal">qc_ha.cx(1,3)</em><br><br>
                                <em class="terminal"># use ccx to write the AND of the inputs on qubit 3</em><br><br>
                                    <em class="terminal">qc_ha.ccx(0,1,3)</em><br><br>
                                        <em class="terminal">qc_ha.barrier()</em><br><br>
                                            <em class="terminal"># extract outputs</em><br><br>
                                                <em class="terminal">qc_ha.measure(2,0) # extract XOR value</em><br><br>
                                                    <em class="terminal">qc_ha.measure(3,1) # extract AND value</em><br><br>

                                                        <em class="terminal">qc_ha.draw(output='mpl')</em><br><br>

                                                    </div>
  <div>
     <img src="foto/q20.png" width="550px" height="250px">
 </div>

<div class="sxt">
Risolvo il quesito 1+1 = 2 <br>

<em class="terminal">counts = execute(qc_ha,Aer.get_backend('qasm_simulator')).result().get_counts()</em><br><br>
    <em class="terminal">plot_histogram(counts)</em><br><br>

</div>

<div>
  <img src="foto/q21.png" width="550px" height="250px">
</div>






   <div class="titoli"> NOISY ON QUANTUM CIRCUIT ON QUANTUM COMPUTERS <br><br>
   </div>
   <div class="terminal">
       Negli esempi sottostanti si costruisce un circuito di 3 qubits e lo si esegue su di un 
       Computer Quantico messo a disposizione dalla IBM.<br>
       Come si evince dal grafico sottostante si hanno degli errori o noisy che generano dei risultati
       imprecisi con più valori di quelli che ci si aspetterebbe.<br>
       Per ovviare a questi effetti si sono create delle utility per mitigare questi effetti come vedremo in seguito.
       <br>   
   </div>
   <div class="sxt">
        <em class="terminal">  from qiskit import * </em><br><br>
        <em class="terminal">   from qiskit.tools.visualization import plot_histogram </em><br><br>
        <em class="terminal">    %matplotlib inline </em><br><br>
        <em class="terminal">    nq = 3 </em><br><br>
        <em class="terminal">     circuit = QuantumCircuit(nq,nq) </em><br><br>
        <em class="terminal">    circuit.h(0) </em><br><br>
        <em class="terminal">    circuit.cx(0,1) </em><br><br>
        <em class="terminal">    circuit.cx(1,2) </em><br><br>
        <em class="terminal">    circuit.measure(range(nq),range(nq)) </em><br><br>
        <em class="terminal">    circuit.draw(output='mpl') </em><br><br>

        <div> circuito di 3 qubit
            <img src="foto/qq1.png" width="550px" height="250px">
          </div>

        <em class="terminal">     simulator = Aer.get_backend('qasm_simulator') </em><br><br>
        <em class="terminal"> result = execute(circuit, backend= simulator, shots = 1024).result() </em><br><br>
        <em class="terminal"> plot_histogram(result.get_counts(circuit)) </em><br><br>


        <div>
            <img src="foto/qq2.png" width="550px" height="250px">
          </div>

<em class="terminal"> IBMQ.load_account() </em><br><br>
<em class="terminal"> prov = IBMQ.get_provider(hub='ibm-q') </em><br><br>
<em class="terminal"> device = prov.get_backend('ibmqx2') </em><br><br>


<em class="terminal"> job = execute(circuit, backend=device, shots= 1024) </em><br><br>
<em class="terminal"> print(job.job_id()) </em><br><br>
<em class="terminal"> from qiskit.tools.monitor import job_monitor </em><br><br>
<em class="terminal"> job_monitor(job) </em><br><br>

  <em class="terminal">5e713e2b707aed00185756d8</em><br><br>
    <em class="terminal">Job Status: job has successfully run</em><br><br>

<em class="terminal"> result_qc = job.result() </em><br><br>
<em class="terminal"> plot_histogram(result_qc.get_counts(circuit)) </em><br><br>

<div>
    <img src="foto/qq3.png" width="550px" height="250px">
  </div>

<em class="terminal"> from qiskit.ignis.mitigation.measurement import (complete_meas_cal,CompleteMeasFitter) </em><br><br>
<em class="terminal"> cms_circuits , stateLabels = complete_meas_cal(qr =circuit.qregs[0], circlabel ='measerrormitigationcal') </em><br><br>
<em class="terminal"> cms_circuits[2].draw(output='mpl') </em><br><br>
<div>
    <img src="foto/qq4.png" width="550px" height="250px">
  </div>

<em class="terminal"> len(cms_circuits)    #2 elevato  n.ro qubits </em><br><br>

<em class="terminal"> #eseguo di nuovo job su Quantum computer e con mitigations complete_meas_cal </em><br><br>

<em class="terminal"> cms_job = execute(cms_circuits, backend= device, shots = 1024, optimization_level=0  ) </em><br><br>
<em class="terminal"> print(cms_job.job_id()) </em><br><br>
<em class="terminal"> job_monitor(cms_job) </em><br><br>
<em class="terminal"> result_cms = cms_job.result() </em><br><br>

<em class="terminal">5e713e7e10ebe9001a2f85cf </em><br><br>
<em class="terminal">Job Status: job has successfully run</em><br><br>

 <em class="terminal"> plot_histogram(result_cms.get_counts(cms_circuits[nq])) </em><br><br>

 <div>
    <img src="foto/qq5.png" width="550px" height="250px">
  </div>

<em class="terminal"> meas_fitter= CompleteMeasFitter(result_cms,stateLabels) </em><br><br>
<em class="terminal"> meas_fitter.plot_calibration() </em><br><br>

<div>
    <img src="foto/qq6.png" width="550px" height="250px">
  </div>

<em class="terminal"> #vediamo quanto abbiamo migliorato < minore noise </em><br><br>

    <em class="terminal"> meas_filter = meas_fitter.filter </em><br><br>
    <em class="terminal"> mitigated_result = meas_filter.apply(result_qc) </em><br><br>
    <em class="terminal"> device_counts = result_qc.get_counts(circuit) </em><br><br>
    <em class="terminal"> mitigated_counts = mitigated_result.get_counts(circuit) </em><br><br>
    <em class="terminal"> plot_histogram([device_counts, mitigated_counts], legend=['device, noisy','device, mitigated']) </em><br><br>

    <div>
        <div class="terminal">
            Nel grafico possiamo osservare i diversi valori ottenuti nella prima elaborazione(noisy) e la seconda con la 
            mitigazione ottenuta con i filtri applicati(mitigated) e si nota che alcuni valori come 010 o 101 passano a zero mentre altri valori hanno un
            risultato minore a vantaggio di 000 e 111.
        
        </div>
        <img src="foto/qq7.png" width="750px" height="250px">
      </div>

    </div>

        <div class="titoli"> THE BERNSTEIN-VAZIRANI-ALGORITHM ON QUANTUM COMPUTING </div>
        <div class="terminal">
        <br>
         Ora esaminiamo l'argoritmo che implemntato in un circuito quantico ci permette di individuare una parola segreta in un solo 
         tentativo mentre con un circuito classico sono necessari tanti tentatvi equivalenti alla lunghezza della parola.     
            <br>   
        </div>
        <div class="sxt">
             <em class="terminal">from qiskit import *</em><br><br>
                <em class="terminal">   from qiskit.tools.visualization import plot_histogram</em><br><br>
                    <em class="terminal">    %matplotlib inline</em><br><br>

                        <em class="terminal">    password = '11111100'</em><br><br>
                            <em class="terminal">        circuit = QuantumCircuit(len(password)+1,len(password))   #</em><br><br>
                                <em class="terminal">       circuit.h(range(len(password)))</em><br><br>
                                    <em class="terminal">circuit.x(len(password))</em><br><br>
                                        <em class="terminal">circuit.h(len(password))</em><br><br>
                                            <em class="terminal">circuit.h(len(password))</em><br><br>
                                                <em class="terminal">circuit.barrier()</em><br><br>

                                                    <em class="terminal">for i, num in enumerate(reversed(password)):</em><br><br>
                                                        <em class="terminal2">  if num  == '1':</em><br><br>
                                                            <em class="terminal3">         circuit.cx(i,len(password))</em><br><br>


 
                                                                <em class="terminal">circuit.barrier()</em><br><br>

                                                                    <em class="terminal">circuit.h(range(len(password)))</em><br><br>

                                                                        <em class="terminal">circuit.barrier()</em><br><br>
                                                                            <em class="terminal">circuit.measure(range(len(password)),range(len(password)))</em><br><br>
                                                                                <em class="terminal">circuit.draw(output='mpl') </em><br><br>

<div>
    <div>
 <div class="terminal">
     Nel grafico possiamo vedere la cotruzione del circuito che implementa l'algoritmo di Bernstein-Vazirani che ci permette 
     di individuare la password inserita e con il quantum computing individuarla con un unico tentativo mentre con un classico 
     circuito si necessita di tanti tentativi di quanti sono i bit che compongono la password nel nostro esempio sarebbero necessari 8 tentativi.
     Partendo da dx a sx es. 00000000 con la funzione AND 00000001 si individua il primo bit a dx poi si fa ancora AND con 00000010 e si individua 
     il 2 bit a dx e così via. Mentre con l'esempio qui riprodotto abbiamo subito a primo tentativo la soluzione.
 </div> 
     
    
    </div>
    <div>
    <img src="foto/qb1.png" width="850px" height="250px">
  </div>
</div>

  <em class="terminal">simulator = Aer.get_backend('qasm_simulator')</em><br><br>
    <em class="terminal">result = execute(circuit, backend= simulator, shots = 1).result()</em><br><br>
        <em class="terminal">counts = result.get_counts()</em><br><br>
            <em class="terminal">print(counts)</em><br><br>

                <em class="terminal">#Sotto il risultato ottenuto  </em><br><br>
                    <em class="terminal">#{'11111100': 1}</em><br><br>




</div>

<div class="titoli"> THE QUANTUM TELEPORTATION </div>
        <div class="terminal">
        <br>
         Nel Quantum Computing si può effettuare il teletrasporto .... non come su STAR TREK ma si possono trasferire delle informazioni da un
         qubit ad un altro qubit ma rimane il NO CLONING THEOREM cioè non si possono clonare dei qubit (no copia/incolla).
         Vediamo un esempio ...  
            <br>   
       </div>
<div class="sxt">
    
        <em class="terminal"> from qiskit import *</em><br><br>
            <em class="terminal">   circuit = QuantumCircuit(3,3)   #3 qubit circuit e 3 classical circuit</em><br><br>
                <em class="terminal">    %matplotlib inline</em><br><br>
                    <em class="terminal">circuit.draw(output='mpl')   #disegno circuito vuoto</em><br><br>
 
    <div>
    <img src="foto/qt1.png" width="850px" height="250px">
  </div>
  <em class="terminal">  circuit.x(0)</em><br><br>
    <em class="terminal">circuit.barrier()</em><br><br>
        <em class="terminal">circuit.draw(output='mpl') </em><br><br>
<div>
<img src="foto/qt2.png" width="850px" height="250px">
</div>
<em class="terminal">CREATE ENTANGLEMENT TRA Q1 and Q2</em><br><br>
<em class="terminal">circuit.h(1)</em><br><br>
    <em class="terminal">circuit.cx(1,2)</em><br><br>
        <em class="terminal">circuit.draw(output='mpl')</em><br><br> 

<div>
<img src="foto/qt3.png" width="850px" height="250px">
</div>
<em class="terminal">circuit.cx(0,1)</em><br><br>
    <em class="terminal">circuit.h(0)</em><br><br>
        <em class="terminal">circuit.draw(output='mpl') </em><br><br>

<div>
<img src="foto/qt4.png" width="850px" height="250px">
</div>
<em class="terminal">circuit.barrier()</em><br><br>
    <em class="terminal">circuit.measure([0,1], [0,1])  #misurazione qubit_reg e classical_reg</em><br><br>
        <em class="terminal">circuit.draw(output='mpl') </em><br><br>
<div>
<img src="foto/qt5.png" width="850px" height="250px">
</div>
<em class="terminal">circuit.barrier()</em><br><br>
    <em class="terminal">circuit.cx(1,2)</em><br><br>
        <em class="terminal">circuit.cz(0,2)</em><br><br>
            <em class="terminal">circuit.draw(output='mpl') </em><br><br>
<div>
<img src="foto/qt6.png" width="850px" height="250px">
</div>
<em class="terminal"></em>QUANTUM TELEPORTATION PROTOCOL</em><br><br>

<em class="terminal">  Trasferire informazioni da un qubit ad altro qubit</em><br><br>


    <em class="terminal">   circuit.measure(2,2)</em><br><br>
        <em class="terminal">   simulator = Aer.get_backend('qasm_simulator')</em><br><br>
            <em class="terminal">   result = execute(circuit, backend = simulator, shots = 1024).result()</em><br><br>
                <em class="terminal">   counts = result.get_counts()</em><br><br>
                    <em class="terminal">   from qiskit.tools.visualization import plot_histogram</em><br><br>
                        <em class="terminal">   plot_histogram(counts)</em><br><br>
<div>
<img src="foto/qt7.png" width="850px" height="250px">
</div>
<em class="terminal">print(counts)</em><br><br>

<em class="terminal">{'111': 254, '100': 277, '101': 239, '110': 254}</em><br><br>

    <em class="terminal">risultato 100 indica C2 = 1 C1 = 0 e C0 = 0 poi 101 indica C2 = 1 C1 = 0 C0 = 1 <br> 
        e così via perchè stiamo misurando c2 --> circuit.measure(2,2) 
    </em><br><br>

</div>




</body>
</html>

